{
    "sourceFile": "Assets/Scripts/Block/BlockTargetManager.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1771535603669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1771638713801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,141 +1,384 @@\n using UnityEngine;\r\n using System.Collections.Generic;\r\n using JellyGunner;\r\n+using System.Collections.Generic;\r\n \r\n public class BlockTargetManager : MonoBehaviour\r\n {\r\n     public static BlockTargetManager Instance { get; private set; }\r\n \r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n     [Header(\"Config\")]\r\n     [SerializeField] private BlockConfigSO _blockConfig;\r\n-    [SerializeField] private Vector2 _spacing = new Vector2(1.1f, 1.1f);\r\n     [SerializeField] private Transform _container;\r\n \r\n-    // Grid: Key = (x, y, layer), Value = Block occupying that cell\r\n-    private Dictionary<Vector3Int, TargetBlock> _grid = new Dictionary<Vector3Int, TargetBlock>();\r\n-    private List<TargetBlock> _activeTargets = new List<TargetBlock>();\r\n+    [Header(\"Grid Layout Settings\")]\r\n+    [Tooltip(\"Start point of the grid (The 'Front' line where targets are valid)\")]\r\n+    [SerializeField] private Vector3 _pivotOffset = Vector3.zero;\r\n+    \r\n+    [Tooltip(\"Distance between columns and rows\")]\r\n+    [SerializeField] private Vector2 _spacing = new Vector2(1.2f, 1.2f);\r\n+    \r\n+    [Tooltip(\"Direction the blocks slide towards (e.g., (0,0,-1) means sliding back-to-front along Z)\")]\r\n+    [SerializeField] private Vector3 _slideDirection = new Vector3(0, 0, -1);\r\n+    \r\n+    [Tooltip(\"Axis defining the Columns (Perpendicular to Slide). Usually (1,0,0)\")]\r\n+    [SerializeField] private Vector3 _columnAxis = new Vector3(1, 0, 0);\r\n \r\n+    [Header(\"Debug\")]\r\n+    [SerializeField] private bool _showGizmos = true;\r\n+    [SerializeField] private Color _gizmoColor = Color.red;\r\n+\r\n+    // Key: Column Index, Value: List of blocks in that column sorted by Depth (0 is closest to pivot)\r\n+    private Dictionary<int, List<TargetBlock>> _columns = new Dictionary<int, List<TargetBlock>>();\r\n+    private List<TargetBlock> _allTargets = new List<TargetBlock>();\r\n+\r\n     private void Awake()\r\n     {\r\n         Instance = this;\r\n+        if (_slideDirection == Vector3.zero) _slideDirection = Vector3.back;\r\n+        _slideDirection.Normalize();\r\n+        _columnAxis.Normalize();\r\n     }\r\n \r\n     public void Initialize(LevelData levelData)\r\n     {\r\n         ClearLevel();\r\n-        if (levelData == null || levelData.waves == null) return;\r\n+        if (levelData == null || levelData.waves == null || levelData.waves.Length == 0) return;\r\n \r\n-        if (levelData.waves.Length == 0) return;\r\n         var wave = levelData.waves[0];\r\n         if (wave.enemies == null) return;\r\n \r\n-        var heightMap = new Dictionary<Vector2Int, int>();\r\n+        // Group raw data by Column (gridX) then sort by Depth (gridY)\r\n+        // Assuming gridX = Column, gridY = Depth for spawn logic\r\n+        var groupedData = new Dictionary<int, List<EnemySpawn>>();\r\n+        foreach(var enemy in wave.enemies)\r\n+        {\r\n+            if(!groupedData.ContainsKey(enemy.gridX))\r\n+                groupedData[enemy.gridX] = new List<EnemySpawn>();\r\n+            groupedData[enemy.gridX].Add(enemy);\r\n+        }\r\n \r\n-        foreach (var spawn in wave.enemies)\r\n+        foreach (var kvp in groupedData)\r\n         {\r\n-            var config = _blockConfig.GetDefinition(spawn.color);\r\n-            if (config == null) continue;\r\n+            int colIndex = kvp.Key;\r\n+            // Sort by gridY (Depth) so smaller Y is closer to front (or farther based on your logic)\r\n+            // Let's assume gridY 0 is front, gridY 1 is behind it, etc.\r\n+            var enemiesInCol = kvp.Value;\r\n+            enemiesInCol.Sort((a, b) => a.gridY.CompareTo(b.gridY));\r\n+            \r\n+            _columns[colIndex] = new List<TargetBlock>();\r\n \r\n-            int startX = spawn.gridX;\r\n-            int startY = spawn.gridY;\r\n-            int currentLayer = 0;\r\n-\r\n-            for (int x = 0; x < config.Size.x; x++)\r\n+            for (int i = 0; i < enemiesInCol.Count; i++)\r\n             {\r\n-                for (int y = 0; y < config.Size.y; y++)\r\n-                {\r\n-                    Vector2Int pos = new Vector2Int(startX + x, startY + y);\r\n-                    if (heightMap.TryGetValue(pos, out int h))\r\n-                    {\r\n-                        if (h > currentLayer) currentLayer = h;\r\n-                    }\r\n-                }\r\n-            }\r\n+                var data = enemiesInCol[i];\r\n+                var config = _blockConfig.GetDefinition(data.color);\r\n+                if (config == null) continue;\r\n \r\n-            SpawnBlock(config, startX, startY, currentLayer);\r\n-\r\n-            int nextLayer = currentLayer + 1;\r\n-            for (int x = 0; x < config.Size.x; x++)\r\n-            {\r\n-                for (int y = 0; y < config.Size.y; y++)\r\n-                {\r\n-                    Vector2Int pos = new Vector2Int(startX + x, startY + y);\r\n-                    heightMap[pos] = nextLayer;\r\n-                }\r\n+                // 'i' becomes the depth index in our runtime logic\r\n+                SpawnBlock(config, colIndex, i);\r\n             }\r\n         }\r\n     }\r\n \r\n-    private void SpawnBlock(BlockConfigSO.BlockDefinition config, int x, int y, int layer)\r\n+    private void SpawnBlock(BlockConfigSO.BlockDefinition config, int col, int depth)\r\n     {\r\n-        Vector3 worldPos = CalculateWorldPosition(x, y, layer, config.Size);\r\n-        GameObject obj = Instantiate(config.Prefab, worldPos, Quaternion.identity, _container);\r\n+        Vector3 pos = CalculateWorldPosition(col, depth);\r\n         \r\n+        GameObject obj = Instantiate(config.Prefab, pos, Quaternion.identity, _container);\r\n         TargetBlock block = obj.GetComponent<TargetBlock>();\r\n         if (block == null) block = obj.AddComponent<TargetBlock>();\r\n \r\n-        block.Initialize(config, x, y, layer, OnBlockDestroyed);\r\n-        _activeTargets.Add(block);\r\n+        block.Initialize(config, col, depth, OnBlockDestroyed);\r\n+        \r\n+        if (!_columns.ContainsKey(col)) _columns[col] = new List<TargetBlock>();\r\n+        _columns[col].Add(block);\r\n+        _allTargets.Add(block);\r\n+    }\r\n \r\n-        for (int i = 0; i < config.Size.x; i++)\r\n+    private void OnBlockDestroyed(TargetBlock block)\r\n+    {\r\n+        if (_allTargets.Contains(block)) _allTargets.Remove(block);\r\n+\r\n+        int col = block.ColumnIndex;\r\n+        if (_columns.ContainsKey(col))\r\n         {\r\n-            for (int j = 0; j < config.Size.y; j++)\r\n-            {\r\n-                _grid[new Vector3Int(x + i, y + j, layer)] = block;\r\n-            }\r\n+            _columns[col].Remove(block);\r\n+            SlideColumn(col);\r\n         }\r\n     }\r\n \r\n-    private void OnBlockDestroyed(TargetBlock block)\r\n+    private void SlideColumn(int colIndex)\r\n     {\r\n-        if (_activeTargets.Contains(block))\r\n+        if (!_columns.ContainsKey(colIndex)) return;\r\n+\r\n+        var list = _columns[colIndex];\r\n+        \r\n+        // Re-index depth from 0 to Count\r\n+        for (int i = 0; i < list.Count; i++)\r\n         {\r\n-            _activeTargets.Remove(block);\r\n+            var targetBlock = list[i];\r\n             \r\n-            var keysToRemove = new List<Vector3Int>();\r\n-            foreach (var kvp in _grid)\r\n+            // If the block is not at the correct visual depth index, move it\r\n+            if (targetBlock.DepthIndex != i)\r\n             {\r\n-                if (kvp.Value == block) keysToRemove.Add(kvp.Key);\r\n+                Vector3 newPos = CalculateWorldPosition(colIndex, i);\r\n+                targetBlock.UpdateGridPosition(i, newPos);\r\n             }\r\n-            foreach (var k in keysToRemove) _grid.Remove(k);\r\n         }\r\n     }\r\n \r\n     public TargetBlock GetTarget(BlockColor color)\r\n     {\r\n         TargetBlock candidate = null;\r\n-        int minLayer = int.MaxValue;\r\n+        float minDistanceSqr = float.MaxValue;\r\n+        Vector3 origin = transform.TransformPoint(_pivotOffset);\r\n \r\n-        foreach (var target in _activeTargets)\r\n+        // Check only the first item (Depth 0) of each column\r\n+        foreach (var kvp in _columns)\r\n         {\r\n-            if (target.ColorType == color && target.HP > 0)\r\n+            var list = kvp.Value;\r\n+            if (list.Count == 0) continue;\r\n+\r\n+            TargetBlock frontBlock = list[0];\r\n+            \r\n+            if (frontBlock.ColorType == color && frontBlock.HP > 0)\r\n             {\r\n-                if (target.LayerIndex < minLayer)\r\n+                // Find the one physically closest to the center/pivot if multiple exist\r\n+                float dist = (frontBlock.transform.position - origin).sqrMagnitude;\r\n+                if (dist < minDistanceSqr)\r\n                 {\r\n-                    minLayer = target.LayerIndex;\r\n-                    candidate = target;\r\n+                    minDistanceSqr = dist;\r\n+                    candidate = frontBlock;\r\n                 }\r\n             }\r\n         }\r\n         return candidate;\r\n     }\r\n \r\n-    private Vector3 CalculateWorldPosition(int x, int y, int layer, Vector2Int size)\r\n+    private Vector3 CalculateWorldPosition(int col, int depth)\r\n     {\r\n-        float xPos = (x + (size.x - 1) * 0.5f) * _spacing.x;\r\n-        float zPos = (y + (size.y - 1) * 0.5f) * _spacing.y;\r\n-        float yPos = layer * 1.0f;\r\n+        // Origin is the Pivot\r\n+        Vector3 origin = transform.TransformPoint(_pivotOffset);\r\n \r\n-        return transform.position + new Vector3(xPos, yPos, zPos);\r\n+        // Move along Column Axis\r\n+        Vector3 colOffset = _columnAxis * (col * _spacing.x);\r\n+\r\n+        // Move along Slide Axis (backwards from slide direction to stack them up)\r\n+        // If items slide towards -Z, they pile up in +Z. So we multiply by -_slideDirection\r\n+        Vector3 depthOffset = -_slideDirection * (depth * _spacing.y);\r\n+\r\n+        return origin + colOffset + depthOffset;\r\n     }\r\n \r\n     private void ClearLevel()\r\n     {\r\n-        foreach (var t in _activeTargets)\r\n+        foreach (var t in _allTargets)\r\n         {\r\n             if (t != null) Destroy(t.gameObject);\r\n         }\r\n-        _activeTargets.Clear();\r\n-        _grid.Clear();\r\n+        _allTargets.Clear();\r\n+        _columns.Clear();\r\n     }\r\n+\r\n+#if UNITY_EDITOR\r\n+    private void OnDrawGizmos()\r\n+    {\r\n+        if (!_showGizmos) return;\r\n+\r\n+        Vector3 origin = transform.TransformPoint(_pivotOffset);\r\n+        \r\n+        // 1. Draw Pivot Point\r\n+        Gizmos.color = Color.yellow;\r\n+        Gizmos.DrawSphere(origin, 0.3f);\r\n+#if UNITY_EDITOR\r\n+        UnityEditor.Handles.Label(origin + Vector3.up, \"Pivot (Target Line)\");\r\n+#endif\r\n+\r\n+        // 2. Draw Slide Direction Arrow\r\n+        Gizmos.color = Color.cyan;\r\n+        Vector3 slideEnd = origin + _slideDirection * 3f;\r\n+        Gizmos.DrawLine(origin, slideEnd);\r\n+        DrawArrow(origin, _slideDirection);\r\n+#if UNITY_EDITOR\r\n+        UnityEditor.Handles.Label(slideEnd, \"Slide Dir\");\r\n+#endif\r\n+\r\n+        // 3. Draw Column Axis Arrow\r\n+        Gizmos.color = Color.green;\r\n+        Vector3 colEnd = origin + _columnAxis * 3f;\r\n+        Gizmos.DrawLine(origin, colEnd);\r\n+        DrawArrow(origin, _columnAxis);\r\n+#if UNITY_EDITOR\r\n+        UnityEditor.Handles.Label(colEnd, \"Column Axis\");\r\n+#endif\r\n+\r\n+        // 4. Visualize Grid Slots (Preview)\r\n+        Gizmos.color = _gizmoColor;\r\n+        int debugCols = 5;\r\n+        int debugDepth = 5;\r\n+\r\n+        for (int c = 0; c < debugCols; c++)\r\n+        {\r\n+            for (int d = 0; d < debugDepth; d++)\r\n+            {\r\n+                Vector3 pos = CalculateWorldPosition(c, d);\r\n+                // Draw wireframe box\r\n+                Gizmos.DrawWireCube(pos, new Vector3(0.8f, 0.2f, 0.8f));\r\n+                \r\n+                // Highlight the \"Active Target\" zone (Depth 0)\r\n+                if (d == 0)\r\n+                {\r\n+                    Color highlight = Color.red;\r\n+                    highlight.a = 0.3f;\r\n+                    Gizmos.color = highlight;\r\n+                    Gizmos.DrawCube(pos, new Vector3(0.9f, 0.1f, 0.9f));\r\n+                    Gizmos.color = _gizmoColor;\r\n+                }\r\n+            }\r\n+            // Draw line connecting column\r\n+            Vector3 start = CalculateWorldPosition(c, 0);\r\n+            Vector3 end = CalculateWorldPosition(c, debugDepth - 1);\r\n+            Gizmos.DrawLine(start, end);\r\n+        }\r\n+    }\r\n+\r\n+    private void DrawArrow(Vector3 pos, Vector3 dir)\r\n+    {\r\n+        Vector3 right = Vector3.Cross(Vector3.up, dir).normalized;\r\n+        Gizmos.DrawLine(pos + dir, pos + (dir - right) * 0.2f);\r\n+        Gizmos.DrawLine(pos + dir, pos + (dir + right) * 0.2f);\r\n+    }\r\n+#endif\r\n }\r\n"
                },
                {
                    "date": 1771638832073,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,154 +6,22 @@\n public class BlockTargetManager : MonoBehaviour\r\n {\r\n     public static BlockTargetManager Instance { get; private set; }\r\n \r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n     [Header(\"Config\")]\r\n     [SerializeField] private BlockConfigSO _blockConfig;\r\n     [SerializeField] private Transform _container;\r\n \r\n     [Header(\"Grid Layout Settings\")]\r\n     [Tooltip(\"Start point of the grid (The 'Front' line where targets are valid)\")]\r\n     [SerializeField] private Vector3 _pivotOffset = Vector3.zero;\r\n-    \r\n+\r\n     [Tooltip(\"Distance between columns and rows\")]\r\n     [SerializeField] private Vector2 _spacing = new Vector2(1.2f, 1.2f);\r\n-    \r\n+\r\n     [Tooltip(\"Direction the blocks slide towards (e.g., (0,0,-1) means sliding back-to-front along Z)\")]\r\n     [SerializeField] private Vector3 _slideDirection = new Vector3(0, 0, -1);\r\n-    \r\n+\r\n     [Tooltip(\"Axis defining the Columns (Perpendicular to Slide). Usually (1,0,0)\")]\r\n     [SerializeField] private Vector3 _columnAxis = new Vector3(1, 0, 0);\r\n \r\n     [Header(\"Debug\")]\r\n@@ -181,12 +49,12 @@\n         if (wave.enemies == null) return;\r\n \r\n         // Group raw data by Column (gridX) then sort by Depth (gridY)\r\n         // Assuming gridX = Column, gridY = Depth for spawn logic\r\n-        var groupedData = new Dictionary<int, List<EnemySpawn>>();\r\n-        foreach(var enemy in wave.enemies)\r\n+        var groupedData = new Dictionary<int, List<Enemy>>();\r\n+        foreach (var enemy in wave.enemies)\r\n         {\r\n-            if(!groupedData.ContainsKey(enemy.gridX))\r\n+            if (!groupedData.ContainsKey(enemy.gridX))\r\n                 groupedData[enemy.gridX] = new List<EnemySpawn>();\r\n             groupedData[enemy.gridX].Add(enemy);\r\n         }\r\n \r\n@@ -196,9 +64,9 @@\n             // Sort by gridY (Depth) so smaller Y is closer to front (or farther based on your logic)\r\n             // Let's assume gridY 0 is front, gridY 1 is behind it, etc.\r\n             var enemiesInCol = kvp.Value;\r\n             enemiesInCol.Sort((a, b) => a.gridY.CompareTo(b.gridY));\r\n-            \r\n+\r\n             _columns[colIndex] = new List<TargetBlock>();\r\n \r\n             for (int i = 0; i < enemiesInCol.Count; i++)\r\n             {\r\n@@ -214,15 +82,15 @@\n \r\n     private void SpawnBlock(BlockConfigSO.BlockDefinition config, int col, int depth)\r\n     {\r\n         Vector3 pos = CalculateWorldPosition(col, depth);\r\n-        \r\n+\r\n         GameObject obj = Instantiate(config.Prefab, pos, Quaternion.identity, _container);\r\n         TargetBlock block = obj.GetComponent<TargetBlock>();\r\n         if (block == null) block = obj.AddComponent<TargetBlock>();\r\n \r\n         block.Initialize(config, col, depth, OnBlockDestroyed);\r\n-        \r\n+\r\n         if (!_columns.ContainsKey(col)) _columns[col] = new List<TargetBlock>();\r\n         _columns[col].Add(block);\r\n         _allTargets.Add(block);\r\n     }\r\n@@ -243,14 +111,14 @@\n     {\r\n         if (!_columns.ContainsKey(colIndex)) return;\r\n \r\n         var list = _columns[colIndex];\r\n-        \r\n+\r\n         // Re-index depth from 0 to Count\r\n         for (int i = 0; i < list.Count; i++)\r\n         {\r\n             var targetBlock = list[i];\r\n-            \r\n+\r\n             // If the block is not at the correct visual depth index, move it\r\n             if (targetBlock.DepthIndex != i)\r\n             {\r\n                 Vector3 newPos = CalculateWorldPosition(colIndex, i);\r\n@@ -271,9 +139,9 @@\n             var list = kvp.Value;\r\n             if (list.Count == 0) continue;\r\n \r\n             TargetBlock frontBlock = list[0];\r\n-            \r\n+\r\n             if (frontBlock.ColorType == color && frontBlock.HP > 0)\r\n             {\r\n                 // Find the one physically closest to the center/pivot if multiple exist\r\n                 float dist = (frontBlock.transform.position - origin).sqrMagnitude;\r\n@@ -317,9 +185,9 @@\n     {\r\n         if (!_showGizmos) return;\r\n \r\n         Vector3 origin = transform.TransformPoint(_pivotOffset);\r\n-        \r\n+\r\n         // 1. Draw Pivot Point\r\n         Gizmos.color = Color.yellow;\r\n         Gizmos.DrawSphere(origin, 0.3f);\r\n #if UNITY_EDITOR\r\n@@ -355,9 +223,9 @@\n             {\r\n                 Vector3 pos = CalculateWorldPosition(c, d);\r\n                 // Draw wireframe box\r\n                 Gizmos.DrawWireCube(pos, new Vector3(0.8f, 0.2f, 0.8f));\r\n-                \r\n+\r\n                 // Highlight the \"Active Target\" zone (Depth 0)\r\n                 if (d == 0)\r\n                 {\r\n                     Color highlight = Color.red;\r\n"
                },
                {
                    "date": 1771638840918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n         if (wave.enemies == null) return;\r\n \r\n         // Group raw data by Column (gridX) then sort by Depth (gridY)\r\n         // Assuming gridX = Column, gridY = Depth for spawn logic\r\n-        var groupedData = new Dictionary<int, List<>>();\r\n+        var groupedData = new Dictionary<int, List<EnemySpawn>>();\r\n         foreach (var enemy in wave.enemies)\r\n         {\r\n             if (!groupedData.ContainsKey(enemy.gridX))\r\n                 groupedData[enemy.gridX] = new List<EnemySpawn>();\r\n"
                },
                {
                    "date": 1771638966092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,14 +49,11 @@\n         if (wave.enemies == null) return;\r\n \r\n         // Group raw data by Column (gridX) then sort by Depth (gridY)\r\n         // Assuming gridX = Column, gridY = Depth for spawn logic\r\n-\r\n         var groupedData = new Dictionary<int, List<LevelData.EnemySpawn>>();\r\n         foreach (var enemy in wave.enemies)\r\n         {\r\n-\r\n-\r\n                         if (!groupedData.ContainsKey(enemy.gridX))\r\n                 groupedData[enemy.gridX] = new List<LevelData.EnemySpawn>();\r\n             groupedData[enemy.gridX].Add(enemy);\r\n         }\r\n"
                }
            ],
            "date": 1771535603669,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing System.Collections.Generic;\r\nusing JellyGunner;\r\n\r\npublic class BlockTargetManager : MonoBehaviour\r\n{\r\n    public static BlockTargetManager Instance { get; private set; }\r\n\r\n    [Header(\"Config\")]\r\n    [SerializeField] private BlockConfigSO _blockConfig;\r\n    [SerializeField] private Vector2 _spacing = new Vector2(1.1f, 1.1f);\r\n    [SerializeField] private Transform _container;\r\n\r\n    // Grid: Key = (x, y, layer), Value = Block occupying that cell\r\n    private Dictionary<Vector3Int, TargetBlock> _grid = new Dictionary<Vector3Int, TargetBlock>();\r\n    private List<TargetBlock> _activeTargets = new List<TargetBlock>();\r\n\r\n    private void Awake()\r\n    {\r\n        Instance = this;\r\n    }\r\n\r\n    public void Initialize(LevelData levelData)\r\n    {\r\n        ClearLevel();\r\n        if (levelData == null || levelData.waves == null) return;\r\n\r\n        if (levelData.waves.Length == 0) return;\r\n        var wave = levelData.waves[0];\r\n        if (wave.enemies == null) return;\r\n\r\n        var heightMap = new Dictionary<Vector2Int, int>();\r\n\r\n        foreach (var spawn in wave.enemies)\r\n        {\r\n            var config = _blockConfig.GetDefinition(spawn.color);\r\n            if (config == null) continue;\r\n\r\n            int startX = spawn.gridX;\r\n            int startY = spawn.gridY;\r\n            int currentLayer = 0;\r\n\r\n            for (int x = 0; x < config.Size.x; x++)\r\n            {\r\n                for (int y = 0; y < config.Size.y; y++)\r\n                {\r\n                    Vector2Int pos = new Vector2Int(startX + x, startY + y);\r\n                    if (heightMap.TryGetValue(pos, out int h))\r\n                    {\r\n                        if (h > currentLayer) currentLayer = h;\r\n                    }\r\n                }\r\n            }\r\n\r\n            SpawnBlock(config, startX, startY, currentLayer);\r\n\r\n            int nextLayer = currentLayer + 1;\r\n            for (int x = 0; x < config.Size.x; x++)\r\n            {\r\n                for (int y = 0; y < config.Size.y; y++)\r\n                {\r\n                    Vector2Int pos = new Vector2Int(startX + x, startY + y);\r\n                    heightMap[pos] = nextLayer;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void SpawnBlock(BlockConfigSO.BlockDefinition config, int x, int y, int layer)\r\n    {\r\n        Vector3 worldPos = CalculateWorldPosition(x, y, layer, config.Size);\r\n        GameObject obj = Instantiate(config.Prefab, worldPos, Quaternion.identity, _container);\r\n        \r\n        TargetBlock block = obj.GetComponent<TargetBlock>();\r\n        if (block == null) block = obj.AddComponent<TargetBlock>();\r\n\r\n        block.Initialize(config, x, y, layer, OnBlockDestroyed);\r\n        _activeTargets.Add(block);\r\n\r\n        for (int i = 0; i < config.Size.x; i++)\r\n        {\r\n            for (int j = 0; j < config.Size.y; j++)\r\n            {\r\n                _grid[new Vector3Int(x + i, y + j, layer)] = block;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void OnBlockDestroyed(TargetBlock block)\r\n    {\r\n        if (_activeTargets.Contains(block))\r\n        {\r\n            _activeTargets.Remove(block);\r\n            \r\n            var keysToRemove = new List<Vector3Int>();\r\n            foreach (var kvp in _grid)\r\n            {\r\n                if (kvp.Value == block) keysToRemove.Add(kvp.Key);\r\n            }\r\n            foreach (var k in keysToRemove) _grid.Remove(k);\r\n        }\r\n    }\r\n\r\n    public TargetBlock GetTarget(BlockColor color)\r\n    {\r\n        TargetBlock candidate = null;\r\n        int minLayer = int.MaxValue;\r\n\r\n        foreach (var target in _activeTargets)\r\n        {\r\n            if (target.ColorType == color && target.HP > 0)\r\n            {\r\n                if (target.LayerIndex < minLayer)\r\n                {\r\n                    minLayer = target.LayerIndex;\r\n                    candidate = target;\r\n                }\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n\r\n    private Vector3 CalculateWorldPosition(int x, int y, int layer, Vector2Int size)\r\n    {\r\n        float xPos = (x + (size.x - 1) * 0.5f) * _spacing.x;\r\n        float zPos = (y + (size.y - 1) * 0.5f) * _spacing.y;\r\n        float yPos = layer * 1.0f;\r\n\r\n        return transform.position + new Vector3(xPos, yPos, zPos);\r\n    }\r\n\r\n    private void ClearLevel()\r\n    {\r\n        foreach (var t in _activeTargets)\r\n        {\r\n            if (t != null) Destroy(t.gameObject);\r\n        }\r\n        _activeTargets.Clear();\r\n        _grid.Clear();\r\n    }\r\n}\r\n"
        }
    ]
}